NOTE:
This is a version of Documentation/CodingStyle (from Linux-3.7.5),
translated into Korean.
Note that the purpose of this file is to be easier to read in Korean and
is not intended as a fork. If you have any comments or updates for this file
please try to update the original English file first.
If this translation is outdated or has any problem with translation,
contact the translator or maintainer of this file.
===
이 문서는 Documentation/CodingStyle (Linux-3.7.5)의
한글 번역본입니다.
이 문서의 내용에 문제나 수정할 것이 있다면 먼저 영어 원문을 확인하고 수정하는
것이 맞습니다. 번역이 잘못되었거나, 영어 원문이 개정되었다면 아래 번역자 또는
문서 관리자에게 연락하시기 바랍니다.

Translated by: Minsuk Lee <minsuk@hansung.ac.kr>
Translated on: SUN 2013 FEB 05

===


		Linux 커널 코딩 스타일

이 짧은 문서는 Linux 커널에서 선호하는 코딩 스타일을 설명합니다. 코딩
스타일이란 꽤 개인적이기 때문에, 다른 사람에게 내 견해를 _강요_할 수는
없습니다만, 내가 관리를 해야만 하는 것들에 적용되어야 하는 것이며,
그 밖의 다른 것들도 이런 식으로 보이면 좋겠다 하는 것입니다.
적어도 이 글의 핵심 내용을 코딩 때 고려해주시면 좋겠습니다.

우선, GNU 코딩 표준을 출력하시기 바랍니다. 읽기 위해서는 아니고,
태웁니다. 아주 상징적이 제스춰로서요.

어쨌거나 시작합니다:


		제 1 장 : 들여쓰기

탭은 8 문자에 해당되므로, 들여쓰기가 8글자씩 됩니다. 그것을 4문자
(더 심하게는 2!)로 만들려는 이단적인 경우가 있는데, 그것은 파이를 3으로
정의하려는 것과 비슷합니다.

근거: 들여쓰기에 관한 모든 생각은 어디에서 제어 블록이 시작되고 끝나는지
을 정의하고자 하는 것입니다. 특별히 당신이 화면을 20시간동안 계속 보고
있어야 한다면, 넓은 들여쓰기를 했을 때, 그것이 어떤 의미가 있는지를 더 쉽게
알 수 있을 것입니다.

최근에 어떤 사람들은 8글자 들여쓰기는 코드를 오른쪽으로 너무 밀어서 80 컬럼
터미널 화면에서 읽기가 어렵다고 주장하기도 합니다. 정답은, 만약 들여쓰기를
세 단계를 넘게 했다면, 뭔가 이미 잘못된 것이고 그 프로그램을 수정해야한다는
것입니다.

요약하면, 8글자 들여쓰기가 읽기도 쉽고, 작성한 함수가 너무 깊게 들어가고
있다는 것을 경고해주는 장점을 가진다는 것입니다. 그 경고는 꼭 새겨들어야
하는 것입니다.

switch 문에서 복수의 들여쓰기를 하는 좋은 방법은 "switch"와 그에 종속된
"case" 레이블을 두 번 들여쓰지 않고 같은 컬럼에 놓는 것입니다. 예:

	switch (suffix) {
	case 'G':
	case 'g':
		mem <<= 30;
		break;
	case 'M':
	case 'm':
		mem <<= 20;
		break;
	case 'K':
	case 'k':
		mem <<= 10;
		/* fall through */
	default:
		break;
	}

뭔가를 감춰야 하는 것이 있지 않다면, 여러 개의 문장을 같은 줄에
두지 마시기 바랍니다.

	if (condition) do_this;
	  do_something_everytime;

여러 개의 할당문도 한 줄에 써서는 안됩니다. 커널 코딩 스타일은 진짜
간단합니다. 기교를 부리지 않은 것입니다.

주석과 문서 그리고 Kconfig를 제외하고는 공백을 들여쓰기 용으로 사용해서는
안됩니다.위의 예는 일부러 잘못 쓴 것입니다.

쓸만한 에디터를 골라서, 각 라인 뒤쪽의 빈탄을 남기기 말아야 합니다.


		제 2 장 : 긴 줄과 문자열 나누기

코딩 스타일은 통상적으로 사용하는 도구를 이용하여 가독성, 보수유지 가능성을
높이기 위한 것입니다.

한 라인은 80 컬럼을 넘지 않도록 합니다. 이 제한은 꼭 지켜져야 하는 제한입니다.

80 컬럼을 넘기는 것이 가독성을 높이면서도 정보를 숨기지 않는 경우는
예외이지만, 80 컬럼을 넘는 문장은 의미있는 단위로 나뉘어져야 합니다.
그렇게 나눠진 다음 줄은 항상 원래 줄보다 훨씬 짧아야 하며, 확실히 오른쪽으로
가 있어야 합니다. 같은 방식이 인자가 많은 함수 선언에도 적용됩니다.
그렇지만 printk 메시지처럼 바로 보여야 하는 스트링을 분리해서는 안됩니다.
그렇게 하면 grep으로 찾아내는 것이 불가능해지기 때문입니다.


		제 3 장: 중괄호와 공백 넣기

C 언어의 스타일에 항상 나오는 것이 중괄호의 위치입니다. 들여쓰기 넓이와 달리
여러 방식 중 한 가지 방식으로만 해야하는 기술적인 이유가 많지는 않습니다.
그러나, 가장 많이 쓰는 방법은 Kerninghan & Ritchie가 보여줬던 방식인
여는 중괄호는 라인의 끝에, 닫는 중괄호는 처음에 나오게 하는 것입니다. 다음:

	if (x is true) {
		we do y
	}

이 방식은 함수가 아닌 모든 문장 블록(if, switch, for, while, do)에도 적용됩니다. 예:

	switch (action) {
	case KOBJ_ADD:
		return "add";
	case KOBJ_REMOVE:
		return "remove";
	case KOBJ_CHANGE:
		return "change";
	default:
		return NULL;
	}

그렇지만 한 가지 특별한 예, 즉 함수에서는 여는 중괄호를 다음 줄의 첫번째
칸에 씁니다. 그래서:

	int function(int x)
	{
		body of function
	}

전 세계의 이단자들은 이 방식에 대하여 일관성이 없다고 주장합니다. 그렇죠.
일관성이 없습니다. 그러나, 올바른 생각을 하는 사람들은 (a) K&R이 _옳고_ 또
(b) K&R이 옳다는 것을 압니다. 더구나 함수는 어쨌거나 특별한 것입니다.
(C 언어에서 함수는 네스팅을 할 수 없습니다.)

아래 예에서처럼, do 문에서의 while이나 if 문에서의 else 처럼, 같은 문장으로
연결된 경우를 제외하고 닫는 중괄호는 한줄에 그것 하나만 있고 다른 것이
없어야 합니다. 

	do {
		body of do-loop
	} while (condition);

그리고

	if (x == y) {
		..
	} else if (x > y) {
		...
	} else {
		....
	}

정당성: K&R

또한, 이런 중괄호 위치는 빈(또는 거의 빈) 라인의 수를 가독성의 훼손없이
줄여줍니다. (25 라인의 터미널을 생각해보면) 화면에 새로운 라인을 넣는 것은
재생가능한 자원이 아니며, 주석을 달 수 있는 빈 라인이 하나 더 확보하는
것입니다.

한 문장으로 해결할 수 있는 경우에 불필요한 중괄호를 넣지 마세요.

if (condition)
	action();

그리고

if (condition)
	do_this();
else
	do_that();

만약 조건문의 오직 한쪽 브랜치만 한 문장일 때는 예외로써 양쪽 브랜치에
모두 중괄호를 사용합니다.

if (condition) {
	do_this();
	do_that();
} else {
	otherwise();
}

		3.1:  공백

공백 문자 사용에 관한 Linux 커널의 스타일은 대개 함수인지 키워드인지에 따라
다릅니다.  키워드 뒤에는 공백을 하나 넣습니다. 중요한 예외는 sizeof, typeof,
alignof와 __attribute__ 입니다. 이것들은 함수처럼 보이기도 합니다. (C 언어
자체는 "struct fileinfo info;"가 선언된 후 "sizeof info"처럼 괄호가
필요없지만, Linux에서는 보통 괄호와 함께 사용됩니다.)

그래서 다음 키워드들 다음에는 공백을 하나 넣습니다.

	if, switch, case, for, do, while

그러나, 다음 예처럼 sizeof, typeof, alignof, or __attribute__ 다음에는
아닙니다:

	s = sizeof(struct file);

괄호로 닫혀있는 식 앞뒤(안)에는 공백을 넣지 않습니다. 다음은 *나쁜예*입니다:

	s = sizeof( struct file );

포인터 데이터나 포인터 타입을 리턴하는 함수를 선언할 때는 '*'를 타입 이름이
아닌 데이터 이름 또는 함수 이름 쪽에 붙입니다. 예:

	char *linux_banner;
	unsigned long long memparse(char *ptr, char **retptr);
	char *match_strdup(substring_t *s);

다음과 같은 대부분의 이항, 삼항 연산자의 앞 뒤에는 공백을 하나 넣습니다:

	=  +  -  <  >  *  /  %  |  &  ^  <=  >=  ==  !=  ?  :

그러나, 일항 연산자 뒤에는 공백을 넣지 않습니다:
	&  *  +  -  ~  !  sizeof  typeof  alignof  __attribute__  defined

다음과 같이 뒤에 붙는 증가, 감소 단항 연산자 앞에는 공백을 넣지 않습니다.
	++  --

다음과 같이 앞에 붙는 증가, 감소 단항 연산자 뒤에는 공백을 넣지 않습니다.
	++  --

구조체의 멤버 연산자인 '.'과 '->' 앞뒤에는 공백을 넣지 않습니다.

각 라인의 끝에 공백을 넣지 않도록 합니다. 자동 (스마트) 들여쓰기 기능이 있는
편집기들은 자기가 알아서 새 라인의 앞쪽에 공백을 넣어주기 때문에 다음 줄을
바로 입력할 수 있게 해줍니다. 하지만, 빈 라인으로 두기 위해, 거기에 코드를
입력하지 않으면 어떤 편집기는 그 공백을 지우지 않기도 합니다. 결과적으로
뒤쪽에 공백이 남아있는 라인이 생기게 됩니다.

git은 패치에서 라인 뒤쪽에 남아있는 공백이 있는지를 경고하며, 그것을 제거하는
옵션을 제공합니다. 그렇지만 하나가 아닌 일련의 패치를 적용할 때, 이 방식은
라인의 내용을 바꿈으로써, 뒤쪽에 있는 패치가 실패하는 이유가 되기도 합니다.


		제 4 장 : 이름 짓기

C 언어는 간결한 언어이며, 이름도 그렇게 지어야 합니다. Modula-2나 Pascal
프로그래머와 달리 C 프로그래머는 ThisVariableIsATemporaryCounter와 같은
귀여운 이름을 짓지 않습니다. C 프로그래머는 그 변수를 훨씬 쓰기 쉽고,
이해하기도 어렵지 않은 "tmp" 라고 이름을 붙입니다. 

대소문자가 섞여있는 이름은 잘 받아들여지 않지만, 글로벌 변수에 대해서는
반드시 그 변수를 잘 설명하는 이름을 붙여야 합니다. 어떤 글로벌 함수에
"foo" 라는 이름을 쓰는 것은 아주 좋지 않습니다.

글로벌 변수(진짜 필요한 경우에만 사용해야 하지만)는 그 의미를 설명할 수 있는
이름을 가져야하며, 글로벌 함수도 마찬가지 입니다. 만약, 어떤 함수가 활성화된
사용자 수를 세는 역할을 한다면 그 함수 이름은 "count_active_users()" 같은
것으로 지어야지, "cntusr()"와 같은 이름을 붙여서는 안됩니다.
 
함수의 타입을 이름으로 인코딩하는 방식(소위, 헝가리인 명명법)은 완전
바보나 하는 짓입니다. 컴파일러가 어쨌거나, 타입을 알고 검사해 낼 수
있으므로, 프로그래머를 헷갈리게만 하는 것입니다. 마이크로소프트가 버그가
많은 프로그램을 만드는 것이 이상한 일이 아닙니다.

로컬 변수 이름은 짧고 핵심적인 이름이어야 합니다. 만일, 임의의 정수인
루프 카운터가 필요하다면, 그곳엔 아마도 'i' 변수를 써야 할 겁니다.
만약 오해할 소지가 없는데도, 그걸 "loop_counter"라고 부르는 것은 생산적이지
않습니다. 마찬가지로 "tmp"도 임시값을 가지고 있다면 어떤 타입의 변수에도
사용할 수 있습니다.

만약, 로컬 변수의 이름을 짓기에서 헤매고 있다면, 소위 함수-성장-홀몬-불균형
증후군이라고 부르는 문제가 생긴 겁니다. 제 6 장 (함수)를 보시기 바랍니다.


		제 5 장: typedef 이용

"vps_t"와 같은 것을 써서는 안됩니다.

구조체와 포인터에 대하여 typedef를 쓰는 것을 잘못입니다. 소스에서

	vps_t a;

와 같은 것은 볼 때, 그것이 어떤 의미인지를 아시겠습니까 ?

반면에 만약 다음과 같이 쓰여져 있다면,

	struct virtual_container *a;

확실히 "a"가 뭔지 알 수 있습니다.

많은 사람이 typedef가 가독성을 높인다고 생각하고 있습니다. 그렇지 않습니다.
typedef는 다음 경우에만 효과가 있습니다:

 (a) 완전히 불투명한 객체 (즉, 어떤 객체가 무엇인지를 숨기기 위해 typedef를
     의도적으로 사용한 경우)

     예: "pte_t" 등. 언제나 정해진 조작 함수를 통해서만 접근이 가능하여,
     내부를 알 필요가 없는 객체

     주의! 내부를 알 수 없게 만드는 것, 조작함수를 두는 것, 그 자체는
     좋지 않습니다. pte_t 등과 같은 것을 불투명하게 만드는 이유는
     진짜로 그 내부에 이식성 있는 엑세스 가능한 정보가 하나도 없기 
     때문입니다.

 (b) 정수가 "int" 인지 "long"인지 혼동을 피할 수 있도록, 정수 타입을
     명확하게 해야하는 경우.

     여기보다는 (d)로 분류해야할 것 같지만, u8/u16/u32은 완벽하게 좋은
     typedef에 해당됩니다.

     또 주의! 여기에도 이유가 필요합니다. 만약 어떤 것이 "unsigned long"
     이라면, 다음과 같이 할 이유가 없습니다.
      
	typedef unsigned long myflags_t;

     그런데, 어떤 환경에서는 "unsigned int" 일 수도 있고, 또 다른
     환경에서는 "unsigned long" 일 수도 있는 확실한 이유가 있다면,
     반드시 typedef를 사용해야 합니다.

 (c) sparse를 이용한 타입-체킹을 위해 문자 그대로 새로운 타입을 만들어야
     하는 경우

 (d) 어떤 예외적인 환경에서 표준 C99 타입과 같은 새로운 타입이 필요할 때.

     눈과 뇌가 'uint32_t'와 같은 표준 타입에 익숙해지는데는 잠깐의
     시간만 들이면 되지만, 어떤 사람은 타입의 사용에 반대합니다.

     그래서 표준 타입과 동등한 Linux 특유의 'u8/u16/u32/u64'와 그것의
     signed 버전의 사용도 허용됩니다. 그래도 코드를 새로 작성할 때,
     반드시 그것을 사용해야 하는 것은 아닙니다.

     기존의 코드를 수정할 때는, 어떤 타입 형태를 사용했든 그 코드가 사용한
     기존 방식을 따라야 합니다.

 (e) 사용자 공간에서 안전한 타입 선언

     사용자 공간에서도 보이는 구조체에 대해서는 C99 타입을 강요할 수 없으며,
     'u32' 형태도 사용할 수 없습니다. 그래서 우리는 사용자 공간에서도
     공유될 수 있는 모든 구조체에서는 __u32, 그리고 그와 유사한 타입을
     사용합니다.

아마 다른 경우도 있을 수 있지만, 위 규칙과 정확하게 맞지 않는다면 typedef를
절대 사용하지 않는 것이 바로 규칙입니다.

일반적으로 포인터나 내부 멤버가 의미를 가지고 직접 엑세스되는 구조체는
typedef 해서는 안됩니다.


		제 6 장: 함수

함수는 짧고 알차고, 한 가지 일만을 해야합니다. 함수는 우리가 아는,
ISO/ANSI 스크린 크기인 80x24를 기준으로한 두 화면안에 들어가야 하고,
한가지 일을 잘 해야 합니다.

함수의 최대 길이는 함수의 복잡성과 들여쓰기 수준에 반비례합니다. 그래서
하나의 긴 (하지만 간단한) case 문으로 구성된 개념적으로 단순한 함수에서
많은 수의 case 각각에서 작은 일들을 하는 해야 할 필요가 있다면, 함수가
길어도 됩니다.

그렇지만, 복잡한 함수가 있는데, 천재가 아닌 고등학교 1학년 학생이 그
함수가 어떤 일을 하는 함수인지를 이해하기 어려울 것이라고 생각하신다면,
함수의 길이를 위에서 말한 최대 길이에 가깝게 맞추어야 할 것입니다.
기능을 설명할 수 있는 이름의 헬퍼 함수들을 사용하시기 바랍니다.
(성능이 문제가 될 수 있다면, 컴파일러가 그 함수들을 inline 하도록 지정할
수도 있으며, 직접하는 것보다 컴파일러가 더 잘 알아서 하게 될 겁니다.)

함수의 또 다른 기준은 로컬 변수의 개수입니다. 5-10개를 넘어서는 안됩니다.
넘는다면 뭔가 잘못된 것입니다. 그렇다면 다시 생각해서 함수를 더 작은 단위로
쪼개야 합니다. 사람의 뇌는 일반적으로 7개까지의 다른 것들을 추적할
수 있으며, 그 수를 넘으면, 혼란스럽다고 느낍니다. 아마 여러분 스스로는
똑똑하다고 생각하시겠지만, 2주 전에 짰던 코드를 이해해야 하는 경우가 많을
겁니다.

소스 파일에서, 함수 사이는 빈 라인 하나로 구분합니다. 함수가 export 된다면,
함수의 닫는 중괄호 바로 다음 줄에 EXPORT* 매크로를 붙입니다. 예:

int system_is_up(void)
{
	return system_state == SYSTEM_RUNNING;
}
EXPORT_SYMBOL(system_is_up);

함수 프로토타입에는 인자와 인자의 데이터타입을 넣습니다. C언어에서는
이것을 하지 않아도 되지만, 소스를 읽는 사람에게는 쉽게 중요한 정보를
제공하는 방법이기때문에 Linux에서는 이 방법을 선호합니다.


		제 7 장 : 함수 종료 위치의 집중

어떤 사람들은 반대하기도 하지만, goto 문에 해당하는 것이 무조건 점프 명령의
형태로 많은 컴파일러에 의해 제공되고 있습니다.

goto문은 여러 곳에서 함수에서 리턴해야 하고, 클린업 같은 공통 작업이 필요한
경우 유용합니다.

그 정당성은 다음과 같습니다:

- 무조건 점프는 이해하고 따라가기 쉽습니다.
- 네스팅을 줄일 수 있습다.
- 코드를 수정할 때, 개별 종료 위치를 고치지 않아서 생기는 에러를 방지합니다.
- 중복 코드를 최적화하는 컴파일러의 일을 줄여줍니다 ;)

int fun(int a)
{
	int result = 0;
	char *buffer = kmalloc(SIZE);

	if (buffer == NULL)
		return -ENOMEM;

	if (condition1) {
		while (loop1) {
			...
		}
		result = 1;
		goto out;
	}
	...
out:
	kfree(buffer);
	return result;
}


		제 8 장: 주석달기

주석은 좋은 것입니다만, 과도한 주석은 역시 위험합니다. 절대로 주석에 코드가
어떻게 도는지를 설명해서는 안됩니다. 코드 자체를 명확하게 동작하도록 작성하는
것이 훨씬 좋습니다. 나쁜 코드를 설명하는 것은 시간의 낭비입니다.

일반적으로 주석은 코드가 어떻게 도는지가 아닌, 무엇을 하는지를 적어야 합니다.
또, 함수 내부에 주석을 다는 것을 피하도록 하시기 바랍니다. 만약 함수가
매우 복잡해서 함수의 부분 부분들에 대하여 따로 주석을 달아야 한다면, 
제 6 장으로 돌아가 다시 읽으시기 바랍니다. 주석에 특별히 기발한 것 (또는
엉망인 것)에 대하여 짧게 기록하거나 경고할 수는 있지만, 그것도 과해서는
안됩니다. 대신에 함수의 머릿 부분에 그 함수가 뭘 하는지, 왜 하는지를 
알리기 위한 주석을 다시기 바랍니다.

커널 API 함수에 대하여 주석을 달 때는 kernel-doc 형식을 따르시기 바랍니다.
Documentation/kernel-doc-nano-HOWTO.txt 문서와 scripts/kernel-doc에 자세한
내용이 있습니다.

Linux의 주석 스타일은 C89의 "/* ... */"  입니다.
C99의 "// ..." 스타일을 사용하지 마시기 바랍니다.

(여러 줄의) 긴 주석은 다음과 같은 형태로 답니다:

	/*
	 * This is the preferred style for multi-line
	 * comments in the Linux kernel source code.
	 * Please use it consistently.
	 *
	 * Description:  A column of asterisks on the left side,
	 * with beginning and ending almost-blank lines.
	 */

net/과 drivers/net/에 있는 파일에서는 다음과 같이 약간 달리합니다:

	/* The preferred comment style for files in net/ and drivers/net
	 * looks like this.
	 *
	 * It is nearly the same as the generally preferred comment style,
	 * but there is no initial almost-blank line.
	 */

기존 타입이던 변형된 타입이던 데이터에 대해서도 주석을 다는 것이 중요합니다.
이를 위해, 한 줄에는 하나의 데이터만 선언합니다 (콤마로 여러 데이터 선언을
구분하지 마세요). 그래야 각 데이터 아이템에 그 용도에 대한 간단한 주석을 달
공간이 생깁니다.


		제 9 장: 엉망으로 만들어 버렸다면

늘 그런 일이 발생하므로, 걱정할 필요가 없습니다. 아마 오랫동안 UNIX를
사용해왔던 선배에게서 GNU emacs의 C 소스 코드 자동 포맷 기능에 대하여 듣고
그런 기능이 있다는 것을 알고 있을 겁니다. 확실히 그렇기는 하지만, emacs의
디폴트 설정으로는 우리가 바라는 결과가 나오지 않습니다. (그냥 아무렇게나
타이핑하는 것이 더 좋을 정도입니다. - 많은 원숭이가 GNU emacs에 타이핑을
한다고 해서 좋은 프로그램이 만들어지지 않습니다.)

그래서 GNU emacs를 지워버리거나, 좀 제대로 된 것으로 만들어야 합니다.
그러기 위해서는 홈 디렉토리의 .emacs 파일에 다음 내용을 추가하면 됩니다.

(defun c-lineup-arglist-tabs-only (ignored)
  "Line up argument lists by tabs, not spaces"
  (let* ((anchor (c-langelem-pos c-syntactic-element))
	 (column (c-langelem-2nd-pos c-syntactic-element))
	 (offset (- (1+ column) anchor))
	 (steps (floor offset c-basic-offset)))
    (* (max steps 1)
       c-basic-offset)))

(add-hook 'c-mode-common-hook
          (lambda ()
            ;; Add kernel style
            (c-add-style
             "linux-tabs-only"
             '("linux" (c-offsets-alist
                        (arglist-cont-nonempty
                         c-lineup-gcc-asm-reg
                         c-lineup-arglist-tabs-only))))))

(add-hook 'c-mode-hook
          (lambda ()
            (let ((filename (buffer-file-name)))
              ;; Enable kernel mode for the appropriate files
              (when (and filename
                         (string-match (expand-file-name "~/src/linux-trees")
                                       filename))
                (setq indent-tabs-mode t)
                (c-set-style "linux-tabs-only")))))

이것이 emacs가 ~/src/linux-trees 아래 있는 C 파일들의 커널 코딩 스타일을
더 잘 맞출 수 있도록 해줄 것입니다.

그러나, emacs로 제대로 된 포맷을 만드는데 실패했더라도 모든 것을 잃어
버리지는 않습니다. "indent"를 쓰시면 됩니다.

다시 반복되지만, GNU indent도 GNU emacs 처럼 바보같은 셋팅 값을 가지고
실행됩니다. 그래서 몇 가지 옵션을 커맨드 라인에 사용해야 합니다.
그렇지만, GNU indent를 만든 사람들도 K&R의 권위를 인정하고 있기 때문에
심하게 나쁘지는 않습니다 (GNU 개발자들은 악마가 아닙니다. 다만,
이 문제에 관하여는 뭔가 잘못 이해하고 있을 뿐입니다.) indent 명령에
"-kr -i8" (K&R, 8 문자 들여쓰기를 의미함) 옵션을 주거나, 최신의
스타일로 들여쓰기를 해주는 "scripts/Lindent"를 사용하시면 됩니다.

"indent"는 많은 옵션이 있습니다. 특별히 주석 부분을 포맷하는 부분에서는
man 페이지를 보는 것이 좋을 겁니다. 그러나 기억할 것은 "indent"가 
나쁜 프로그램을 고쳐주지는 않는다는 것입니다.


		제 10 장: Kconfig 설정 파일

소스 트리에 있는 모든 KConfig* 설정 파일의 들여쓰기는 사뭇 다릅니다.
config 정의 아래에 있는 라인들은 하나의 탭만큼 들여쓰기가 되어 있고,
help 텍스트들은 거기에서 두개의 공백만큼 더 들여씁니다. 예를 들면:

config AUDIT
	bool "Auditing support"
	depends on NET
	help
	  Enable auditing infrastructure that can be used with another
	  kernel subsystem, such as SELinux (which requires this for
	  logging of avc messages output).  Does not do system-call
	  auditing without CONFIG_AUDITSYSCALL.

아직 안정적이지 않은 기능에 대해서는 "EXPERIMENTAL"에 종속되도록 합니다:

config SLUB
	depends on EXPERIMENTAL && !ARCH_USES_SLAB_PAGE_STRUCT
	bool "SLUB (Unqueued Allocator)"
	...

(파일 시스템에 쓰기 지원을 한다거나 하는) 심각하게 위험성이 있는 기능에
대해서는 그 사실을 프롬프트 스트링에 눈에 띄게 드러내야 합니다:

config ADFS_FS_RW
	bool "ADFS write support (DANGEROUS)"
	depends on ADFS_FS
	...

설정 파일에 관한 완전한 문서는 Documentation/kbuild/kconfig-language.txt
입니다.


		제 11 장: 데이터 구조

싱글 쓰레드가 아닌 환경에서 생성되고 폐기되는 데이터 구조에는 항상 레퍼런스
카운터를 사용해야 합니다. 커널에는 가비지 콜렉터가 돌지 않으며, 커널 밖에서도
가비지 콜렉션은 느리고 비효율적입니다. 따라서, 그런 데이터를 사용하는 모든
경우를 레퍼런스 카운터로 관리해야 한다는 것을 의미합니다.

레퍼런스 카운트를 사용해서 lock을 피할 수 있고, 여러 사용자가 데이터 구조를
동시에 사용할 수 있도록 해주며, 슬립 상태에 들어가거나 잠시 다른 일을 할 때,
사용하고 있던 데이터 구조가 갑자기 없어져 버릴지도 모른다는 걱정을 하지
않아도 됩니다.

lock은 레퍼런스 카운트를 대치하지 않습니다. lock은 데이터 값의 일관성을
유지해 주는 반면에, 레퍼런스 카운트는 메모리 관리 기법입니다. 보통 둘 다
필요하고, 혼동이 있어서는 안되겠습니다.

다른 클래스의 사용자가 있는 경우에는 데이터 구조에 두 단계의 레퍼런스
카운팅이 필요합니다. 서브클래스 카운트는 서브클래스 사용자 수를 유지하며,
서브클래스 카운트가 0이 되면 글로벌 레퍼런스 카운터 값을 딱 한번만 1만큼
줄입니다.

이런 종류의 다단계 레퍼런스 카운팅은 메모리 관리("struct mm_struct":
mm_users 와 mm_count). 파일 시스템 ("struct super_block": s_count 와
s_active) 코드에서 찾아볼 수 있습니다.

꼭 기억해야할 것: 만약 다른 쓰레드가 데이터 구조를 찾을 수 있는데, 레퍼런스
카운트를 가지고 있지 않다면, 거의 확실히 그건 버그입니다.


		제 12 장: macro, enum, RTL

상수를 정의하는 매크로 이름과 enum의 레이블들은 모두 대문자로 합니다.

#define CONSTANT 0x12345

여러 개의 연관된 상수를 정의할 때는 enum을 사용하는 것이 좋습니다.

대문자의 매크로 이름이 보통 맞지만, 함수처럼 동작하는 매크로의 경우에는
소문자를 쓸 수 있습니다.

일반적으로, 인라인 함수가 함수형 매크로를 쓰는 것보다 좋습니다.
 
여러 문장으로 구성된 매크로는 do - while 블록으로 묶습니다.

#define macrofun(a, b, c) 	\
	do {					\
		if (a == 5)			\
			do_this(b, c);	\
	} while (0)

매크로를 사용할 떄 하지 말아야 할 것들:

1) 제어 흐름에 영향을 주는 매크로:

#define FOO(x)					\
	do {					    \
		if (blah(x) < 0)		\
			return -EBUGGERED;	\
	} while(0)

위 예는 아주 좋지 않습니다. 위 매크로는 함수처럼 보이지만, 호출한 함수에서
빠져 나갑니다. 코드를 읽는 사람들이 가늠하기 어려운 일을 해서는 안됩니다.

2) 선언에 포함되지 않은 이름의 로컬 변수를 가진 매크로

#define FOO(val) bar(index, val)

위 예는 별 문제 없어 보이는 것 같지만, 코드를 읽을 때 완전히 혼란스러울
뿐아니라, 별 심각하지 않은 코드 변경에도 문제를 일으킬 수 있습니다.

3) L-value로 사용될 수 있는 인자가 있는 매크로: FOO(x) = y; 는 누군가 FOO를
인라인 함수로 바꾸는 경우, 문제가 발생하게 됩니다.

4) 우선 순위의 상실: 수식을 포함한 상수를 정의하는 매크로는 반드시 수식을
괄호로 둘러쌓야 합니다. 인자가 있는 매크로에서도 같은 문제가 발생할 수 있습니다:

#define CONSTANT 0x4000
#define CONSTEXP (CONSTANT | 3)

cpp 매뉴얼은 매크로에 대하여 자세히 다루고 있습니다. 커널에서 사용되는
어셈블리 언어에서 자주 사용되는 RTL과 관련해서는 gcc internals 매뉴얼을
참조하세요.


		제 13 장: 커널 메시지의 출력

커널 개발자라면 아마 교양있어 보이고 싶어할 것입니다. 커널 메시지의 스펠링에
신경을 써서 좋은 인상을 주시기 바랍니다. "dont" 와 같은 비문 대신
"do not"이나 "don't"를 사용하시기 바랍니다. 메시지는 간결하고, 모호하지
않게 쓰시기 바랍니다.

커널 메시지는 구둣점으로 끝나지 않아도 좋습니다.

숫자를 출력할 때, (%d)처럼 괄호를 씌우는 것은 아무 의미가 없으므로 피해야
합니다.

<linux/device.h>에는 수 많은 드라이버 모델에 대한 진단 메시지 매크로들이
있습니다. 적절한 장치와 드라이버에 맞으면서도, dev_err(), dev_warn(),
dev_info() 등 적절한 수준을 따르도록 메시지를 만들어야 합니다.
특정 장치와 연계되지 않는 메시지에 대해서는 <linux/printk.h>에 정의된
pr_debug()와 pr_info()를 쓰시기 바랍니다.

좋은 디버깅 메시지를 출력하는 것은 아주 도전적인 일입니다. 그렇게만 된다면,
다른 사람이 문제를 해결하는데 큰 도움이 됩니다. 그런 메시지는 DEBUG 심볼이
정의되지 않으면 컴파일되지 않도록 해야 합니다 (즉, 디폴트로 포함되지
않는다는 것입니다.) dev_dbg()나 pr_debug()를 쓰면 자동으로 그렇게 됩니다.
많은 서브시스템들은 -DDEBUG를 켜기 위해서 Kconfig 옵션을 사용합니다.
또 이와 관련해서, 이미 DEBUG가 켜있는 경우, VERBOSE_DEBUG를 사용하여
dev_vdbg() 메시지를 나오게 하기도 합니다.


		제 14 장: 메모리의 할당

커널은 kmalloc(), kzalloc(), kmalloc_array(), kcalloc(), vmalloc(),
vzalloc()와 같은  범용 메모리 할당 함수를 제공합니다. 각각에 대한 세부 정보는
API 문서를 참고하시기 바랍니다.

구조체의 크기를 전달하는 좋은 방법은 다음과 같이 하는 것입니다:

	p = kmalloc(sizeof(*p), ...);

구조체의 이름을 다 쓰는 방법을 쓸 수도 있지만, 그것은 가독성을 떨어뜨리며,
포인터 변수 타입이 변경된 경우, 메모리 할당 함수에는 다른 크기가 전달되어
버그가 생길 수도 있습니다.

void 포인터인 리턴 값의 타입 변환은 불필요합니다. C 언어에서 void 포인터에서
다른 포인터로의 타입 변환이 보장되기 때문입니다.

배열을 할당하는 경우에는 다음과 같이 하는 것이 좋습니다:

	p = kmalloc_array(n, sizeof(...), ...);

0으로 초기화된 배열이라면 다음과 같이 합니다:

	p = kcalloc(n, sizeof(...), ...);

양쪽 모두, 할당 크기인 n * sizeof(...)에 대하여 오버플로우 검사를 하게되며,
실제 오버플로우가 발생하면 NULL을 리턴합니다.


		제 15 장: inline 병

gcc의 "inline"을 "빨리 돌게 해주세요"라는 마법같은 옵션이라고 생각하는 것이
보통인 것 같습니다. inline을 (제 12 장의 매크로를 대치하는 목적으로 사용하는
예에서처럼) 적절히 사용하면 좋지만 종종 그렇지 않은 경우도 있습니다.
inline 키워드를 많이 사용하면 커널이 매우 커집니다. 그 결과 CPU의 명령어 캐쉬
점유량도 커지고, 페이지 캐쉬를 위한 메모리도 부족해져서, 전체 시스템은
느려지게 됩니다. 쉽게 생각하면, 페이지 캐쉬에서 미스가 나면, 디스크가 돌게
되는데, 대개 5msec 정도가 소요됩니다. 그 5msec 동안 CPU는 정말 많은 일을
할 수 있습니다.

상식적인 규칙은 세 줄이상의 코드가 있는 함수에는 inline을 붙이지 않도록
합니다. 만약 그 함수에 전달되는 인자가 컴파일 시에 할 수 있는 상수이고,
그 상수 때문에 함수의 대부분이 최적화되어 없어지는 것이 확실하다면
예외입니다. kmalloc() 인라인 함수가 그 좋은 예입니다.

종종, static 선언되고 딱 한군데에서 호출되는 함수의 경우, inline이 공간을
늘리지 않기 때문에 inline을 붙여도 좋지 않는가에 대한 논란이 있습니다.
기술적으로는 맞지만, gcc는 inline을 하지 않아도 자동으로 그렇게 할 능력을
가지고 있습니다. 그리고 어차피 gcc가 inline 처리를 하게될 텐데, gcc에게 그걸
명시적으로 알려주는 것의 잠재적 가치가 그 함수를 다른 곳에서 한번 더
호출하게 될 때, inline을 이제 없애야 하는 유지보수 관점에서의 이슈보다는
크지 않습니다. 


		제 16 장: 함수의 리턴값과 이름

함수는 아주 다양한 종류의 값을 리턴할 수 있습니다. 그 중 가장 흔한 것은
함수가 성공했는지 실패했는지를 나타내는 값입니다. 그 값은 에러코드 정수
(-Exxx = 실패, 0 = 성공) 또는 "succeeded" 불리언 값(0 = 실패, non-zero =
성공)으로 표현됩니다.

이 두 종류의 표현을 섞어 쓰는 것은 버그를 찾기 어렵게 만드는 주요한
원인입니다. C 언어가 정수와 불리언 값을 명확하게 구분할 수 있도록 만들어
졌다면 컴파일러가 이러한 실수를 우리 대신 찾아줄 수 있겠지만, 그렇지
않습니다. 그런 버그를 줄이기 위해서는 다음과 같은 방식을 사용합니다:

	만약, 함수의 이름이 어떤 행위나, 명령을 나타내는 것이라면, 그 함수는
	에러코드 정수를 리턴하도록 만들어야 합니다. 만약에 그 이름이 명제를
	나타낸다면, 그 함수는 "succeeded" 불리언 값을 리턴해야 합니다.

예를 들어, "add work"는 명령입니다. 따라서 add_work() 함수는 성공한 경우 0을,
실패한 경우 -EBUSY를 리턴해야 합니다. 같은 방식으로 "PCI device present"는
명제입니다. 따라서 pci_dev_present() 함수는 해당하는 장치를 찾았다면
성공으로 1을 리턴하고 그렇지 않다면 0을 리턴하도록 해야합니다.

모든 EXPORT된 함수는 이 방식을 반드시 따라야 하며, 모든 공개된 함수도
마찬가지입니다. 내부적으로 사용하는 (static) 함수의 경우에도 반드시 따를
필요는 없지만, 그렇게 할 것을 권합니다.

함수의 리턴값이 어떤 계산의 성공 여부가 아니라, 계산의 결과 값이라면 이런
규칙이 적용되지 않습니다. 일반적으로 그런 함수들은 어떤 범위를 벗어난 값을
리텀함으로써 실패를 표시합니다. 그 전형적인 예가 포인터를 리턴하는
함수들입니다; 그 함수들은 실패했을 때 NULL이나 ERR_PTR 메커니즘을 사용합니다.


		제 17 장: 커널 매크로를 다시 만들지 않기

include/linux/kernel.h 헤더 파일에는, 조금 다른 버전을 직접 코딩해서 만들
필요가 없을 정도로, 수 많은 매크로들이 정의되어 있습니다. 예를들어, 배열의
길이를 계산할 필요가 있을 때, 다음 매크로를 사용할 수 있습다.

  #define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))

유사하게 어떤 구조체의 한 멤버의 크기를 계산할 때, 다음 매크로를 쓰면 됩니다

  #define FIELD_SIZEOF(t, f) (sizeof(((t*)0)->f))

또한 필요하다면 엄격한 타입 검사를 하는 min(), max() 매크로도 있습니다. 헤더
파일을 숙독하여 어떤 것이 이미 정의되어 있는지를 확힌하고, 당신의 코드에서
같은 것을 다시 만들기 않기를 바랍니다.


		제 18 장: 에디터 모드 라인과 다른 자질구레한 것들

어떤 편집기는 소스 파일에 특별한 마커로 표시된 설정 정보를 넣어 이용합니다.
예를 들어 emacs는 다음과 같은 마커가 포함된 라인을 해석해서 사용합니다. 

-*- mode: c -*-

또 다음과 같은 것도 있습니다:

/*
Local Variables:
compile-command: "gcc -DMAGIC_DEBUG_FLAG foo.c"
End:
*/

vim도 다음과 같은 마커를 해석합니다:

/* vim:set sw=8 noet */

소스에 위와 같은 것을 포함하지 않도록 합니다. 사람들은 자기 자신의 에디터
설정을 가지고 있으며, 소스 파일이 그것을 무시하게 해서는 안됩니다. 이런
것에는 들여쓰기 설정과 에디터 모드 마커가 있습니다. 사람들은 각자 자신의
에디터 모드를 사용하거나 들여쓰기가 잘 되도록하는 나름의 비법들을 다 가지고
있을 수 있습니다.


		제 19 장: 인라인 어셈블리

아키텍처 종속적인 코드에서는 CPU 또는 플랫폼 기능을 이용하기 위해 인라인
어셈블리가 필요할 수 있습니다. 필요한 경우 사용을 주저할 필요는 없습니다.
그렇지만 C 코드도 할 수 있는 일에 불필요하게 인라인 어셈블리를 써서는
안됩니다. 가능하면 C 언어로 하드웨어를 제어해야 하고 그렇게 할 수 있습니다.

인라인 어셈블리의 자주 나오는 코드들은, 조금씩 바꿔가며 반복적으로 쓰기보다는
간단한 헬퍼 함수로 만들어 사용하는 방법을 고려하시기 바랍니다. 인라인
어셈블리에서도 C 언어 파라메터를 사용할 수 있다는 점도 기억하십시오.

크고, 사소하지 않은 어셈블리 함수는 .S 파일로 만들어져야하며, C 헤더 파일에
C 프로토타입 선언이 되어있어야 합니다. 어셈블리 함수를 위한 C 프로토타입에는
"asmlinkage"를 사용해야 합니다.

작성된 asm 문장을, gcc가 그 문장들이 하는 일을 알아차리지 못하고 제거해
버리는 것을 방지하기 위하여 volatile로 만들어야 할 수도 있습니다. 그렇지만,
그렇게 하는 경우, 최적화가 제한될 수 있기 때문에, 언제나 그렇게 할 필요는
없습니다.

여러 개의 명령이 포함된 한 줄짜리 인라인 어셈블리 코드를 작성할 때는, 각
명령을 독립된 라인에, 인용 부호로 구분된 독립된 문자열에 넣어야 합니다.
그리고 어셈블리 출력에서 다음 명령이 적절히 들여쓰기 될 수 있도록 마지막
문자열을 제외하고는 문자열을 \n\t로 끝내야 합니다:

	asm ("magic %reg1, #42\n\t"
	     "more_magic %reg2, %reg3"
	     : /* outputs */ : /* inputs */ : /* clobbers */);


		부록 1: 참고 문헌

The C Programming Language, Second Edition
by Brian W. Kernighan and Dennis M. Ritchie.
Prentice Hall, Inc., 1988.
ISBN 0-13-110362-8 (paperback), 0-13-110370-9 (hardback).
URL: http://cm.bell-labs.com/cm/cs/cbook/

The Practice of Programming
by Brian W. Kernighan and Rob Pike.
Addison-Wesley, Inc., 1999.
ISBN 0-201-61586-X.
URL: http://cm.bell-labs.com/cm/cs/tpop/

K&R과 이 문서에 부합하는 cpp, gcc, gcc internals, indent의 GNU 매뉴얼은 모두
http://www.gnu.org/manual/ 에서 찾을 수 있습니다.

WG14는 C 프로그래밍 언어의 국제 표준을 만드는 워킹 그룹입니다.
URL: http://www.open-std.org/JTC1/SC22/WG14/

Kernel CodingStyle, by greg@kroah.com at OLS 2002:
http://www.kroah.com/linux/talks/ols_2002_kernel_codingstyle_talk/html/
